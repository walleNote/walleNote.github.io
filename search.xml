<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从存储器到内存映射布局]]></title>
    <url>%2F2018%2F01%2F04%2Fmemory-standard-segment-layout%2F</url>
    <content type="text"><![CDATA[就算影子也会在黑暗的时候离开 在日常工作中，经常会有同学提出这样的问题， “我的程序运行时究竟占用了多大的内存?” “我的程序占用的虚拟内存非常大，这个正常么?” 本文主要从以下几个方向，深入浅出的说明内存的基本布局，后续会更新内存的管理的文章。 计算机体系结构 存储器缓存策略 虚拟内存 虚拟地址 进程的内存划分方案 计算机体系结构计算机技术领域的变化日新月异，集成电路技术带来的元件不仅种类繁多，而且在功能方面还在不断改进增强。按照摩尔定律，集成电路上可容纳的晶体管数目大约每两年便会增加一倍。而与晶体管数据量密切相关的处理能力也将提升一倍。 经验告诉我们，想要应对这种快速的变化，就是在经常变动的实现层次之上，利用抽象和泛华的方法为计算机系统定义全局目标和结构体系。这种方法的核心在于描述抽象的方式，该方式要确保在去除相对无关的实现细节后，任何新的实现与核心定义都能保持一致。 整个计算机体系结构可用下图表示: 在计算机系统中，有一些和存储器相关的趣事： 人们对存储器容量总是无法满足，而且存储器容量总是供不应求。 存储器技术似乎是导致处理器性能障碍的主要原因– 这种被称为”处理器和存储器之间的速度鸿沟(The processor-memory gap)” 存储器的访问能力与其存储容量成反比。 存储器缓存策略我们从程序员、设计师和工程师的角度，我们希望系统能够以最快的速度访问所有可用存储器。但是这个基本上是不可能的，实际上系统并不是使用所有的存储器，而是仅仅是在某些时段内使用某一部分存储器。这个情况下，只需要为程序预留相对最快的存储器，而让那些并非立即执行的代码或者数据使用相对较慢的存储器。当CPU立即需要执行指令时，在执行到存储在较慢的存储器上的代码之前，这些代码会转存在较快的存储器中，这种策略称为”缓存”。 缓存策略无处不在，横跨多个级别的存储器，如下图所示： 虚拟内存我们用名为”进程”的抽象概念来表示正在运行的程序。现在多任务操作系统的设计允许一个或者多个用户并发地运行多个程序，对于一个普通用户来说，同时运行多个应用程序（比如听歌、看网页、编辑文档）在正常不过了。 通过虚拟内存的概念，可以很好的解决内存需求与有限的内存容量之间的矛盾，运行时的物理内存会被划分成数个小的分段（页），每个页都可以用来同步执行程序。正在运行的程序的完整内存布局会被保存在低速存储器（磁盘）中。只有那些当前即将被执行的一部分内存（代码和数据）才会被加载到物理内存页中。 首先需要强调的是虚拟内存不同于物理内存，二者属于不同层面的东西。进程占用虚拟内存空间大并非意味着程序的物理内存也一定占用很大。虚拟内存是操作系统内核为了对进程地址空间进行管理(process address space management)而设计的一个逻辑意义上的内存空间概念，我们程序中的指针其实都是这个虚拟内存空间中的地址。 虚拟地址(virtual address): CPU启动保护模式后，程序运行在虚拟地址空间中。 注意，并不是所有的“程序”都是运行在虚拟地址中。 CPU在启动的时候是运行在实模式的，Bootloader以及内核在初始化页表之前并不使用虚拟地址，而是直接使用物理地址的。 虚拟地址范围：编程模型假定地址空间的范围在0到$2^N$，其中N是32或者64。 比如我们写完一个C/C++项目之后，采用gcc/g++进行编译，这个时候编译器采用的地址其实就是虚拟内存空间的地址。因为这时程序都没有开始运行，所以何谈物理内存空间地址？ 凡是程序运行过程中可能需要用到的指令或者数据都必须在虚拟内存空间中。既然说虚拟内存是一个逻辑意义上(逻辑存在)的内存空间，为了能够让程序在物理机器上运行起来，那就需要有一套机制可以让这些虚拟内存空间映射到物理内存空间(真实内存条上的空间)。 在Linux中，解决这个问题的关键是一个叫做 page table (PT页面转换表) 的结构。Linux把物理内存分为了固定统一大小的块，称为page(页)，一般为4KB，并且每个页都有一个编号”page frame number”。这样一个512M大小的内存将包括128K个页。这种方式称为paging，使得操作系统对内存的管理更方便。page table的作用就是将进程操作的地址(虚拟地址)转换成物理地址。 关于 page table 内容原理，可以参考以下文章。 Linux Page Tables ： www.linux-tutorial.info/modules.php?name=MContent&amp;pageid=307 内核会为系统中每一个进程维护一份相互独立的页映射表，页映射表的基本原理是将程序运行过程中需要访问的一段虚拟内存空间通过页映射表映射到一段物理内存空间上，这样CPU访问对应虚拟内存地址的时候就可以通过这种查找页映射表的机制访问物理内存上的某个对应的地址。 “页(page)”是虚拟内存空间向物理内存空间映射的基本单元。 虚拟内存的概念如下图所示： 上图演示了虚拟内存空间和物理内存空间的相互关系。它们通过Page Table关联起来。 其中虚拟内存空间中着色部分分别被映射到了物理内存空间对应相同的着色的部分。而虚拟内存空间中灰色的部分表示在物理内存空间中没有与之对应的部分，也就是说灰色部分没有被映射到物理内存空间中。因为虚拟内存空间很大，可能其中很多部分在一次程序运行中根本不需要访问，所以也就没有必要讲虚拟内存空间中的这些部分映射到物理内存空间上。 那么，总结一下，虚拟内存就是一个逻辑存在的内存空间，在程序运行过程中虚拟内存空间中需要被访问的部分会被映射到物理内存空间。虚拟内存空间大只能表示程序运行过程中可访问的空间比较大，不代表物理内存空间占用也大。 驻留内存顾名思义是指那些被映射到进程虚拟内存空间的物理内存。上图3中，在系统物理内存空间中被着色的部分都是驻留内存。 比如，A1、A2、A3和A4是进程A的驻留内存；B1、B2和B3是进程B的驻留内存。 进程的驻留内存就是进程实实在在占用的物理内存。一般我们所讲的进程占用了多少内存，其实就是说的占用了多少驻留内存而不是多少虚拟内存。因为虚拟内存大并不意味着占用的物理内存大。 以下为具体示例： 操作系统：Linux（Redhat 7.4） 内存信息1234[root(jihaodong)@redhat work]# free total used free shared buff/cache availableMem: 131455940 54627048 12895764 178028 63933128 76268692Swap: 32767996 134996 32633000 Key Desc Mem.total 物理内存的总量 Mem.used 使用的物理内存的总量 Mem.free 空闲内存总量 Mem.shared 共享内存 Mem.buff 内核缓冲区使用的内存 Mem.cache 页面缓存和Slab分配器使用的内存 Mem.available 系统空闲内存 Mem.available = Mem.free + Mem.buff + Mem.cache Swap.total 交换分区总大小，系统物理内存不够用时，与swap进行交换 Swap.used 已经被使用的交换分区大小 Swap.free 未被使用的交换分区大小 进程的TOP信息：1234567891011121314151617[root(jihaodong)@redhat work]# top -d 1 top - 14:30:32 up 28 days, 2:25, 1 user, load average: 0.22, 0.31, 0.25Tasks: 398 total, 1 running, 397 sleeping, 0 stopped, 0 zombie%Cpu(s): 3.5 us, 0.3 sy, 0.0 ni, 96.2 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 13145593+total, 12901476 free, 54629708 used, 63924756 buff/cacheKiB Swap: 32767996 total, 32632996 free, 135000 used. 76267056 avail Mem scroll coordinates: y = 1/398 (tasks), x = 1/12 (fields) PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 5746 elastic+ 20 0 0.233t 0.060t 0.011t S 100.0 48.8 7155:16 /opt/soft/jdk/jdk1.8.0_66/bin/java -Xms48g -Xmx48g -XX:+UseConcMa+ 31299 root 20 0 4283448 305600 2368 S 0.0 0.2 51:26.88 java -XX:PermSize=128m -XX:MaxPermSize=256m -Xms512m -Xmx512m -cp+ 7104 elastic+ 20 0 1277408 99848 6260 S 0.0 0.1 93:41.92 ./bin/../node/bin/node --no-warnings ./bin/../src/cli 18809 root 20 0 2921264 47312 4168 S 10.0 0.0 294:00.58 /usr/local/bin/xcdc run s1.js 18811 root 20 0 2663044 45584 4124 S 5.0 0.0 286:10.11 /usr/local/bin/xcdc run s3.js 18810 root 20 0 2724032 45428 3980 S 5.0 0.0 298:59.47 /usr/local/bin/xcdc run s2.js 18813 root 20 0 2930092 44012 4116 S 5.0 0.0 288:44.38 /usr/local/bin/xcdc run s5.js 18812 root 20 0 2924452 43312 4024 S 0.0 0.0 291:19.32 /usr/local/bin/xcdc run s4.js 10189 root 20 0 2350900 29800 2444 S 0.0 0.0 38:41.39 ./falcon-agent -c cfg.json Key Desc PID 进程ID PPID 父进程ID UID 进程所有者的用户ID USER 进程所有者的用户名 PR 优先级 NI NICE值，负值表示搞优先级，正值表示优先级底 VIRT 进程所用的虚拟内存总量， VIRT = SWAP + RES SWAP 进程使用的虚拟内存中，被置换出去的大小 RES 进程使用的，未被置换出去的物理内存，（目前占用物理内存的值） SHR 共享内存大小 搞清楚了虚拟内存的概念之后解释VIRT就很简单了，VIRT表示虚拟内存空间大小结合图1(计算机体系结构抽象），对应到图3(虚拟内存空间到物理内存空间的映射）中来说就是A1、A2、A3、A4以及灰色部分所有空间的总和。也就是说虚拟包含了在已经映射到物理内存空间的部分和尚未映射到物理内存空间的部分的总和。 RES的含义是指进程虚拟内存空间中已经映射到物理内存空间的那部分的大小。对应到图1中的进程A来说就是A1、A2、A3以及A4几个部分空间的总和。所以说，看进程在运行过程中占用了多少内存应该看RES的值而不是VIRT的值。 最后来看看SHR所表示的含义。SHR是share（共享）的缩写，它表示的是进程占用的共享内存大小。在上图1中我们看到进程A虚拟内存空间中的A4和进程B虚拟内存空间中的B3都映射到了物理内存空间的A4/B3部分。咋一看很奇怪。为什么会出现这样的情况呢？其实我们写的程序会依赖于很多外部的动态库（.so），比如libc.so、libld.so等等。这些动态库在内存中仅仅会保存/映射一份，如果某个进程运行时需要这个动态库，那么动态加载器会将这块内存映射到对应进程的虚拟内存空间中。多个进展之间通过共享内存的方式相互通信也会出现这样的情况。这么一来，就会出现不同进程的虚拟内存空间会映射到相同的物理内存空间。这部分物理内存空间其实是被多个进程所共享的，所以我们将他们称为共享内存，用SHR来表示。某个进程占用的内存除了和别的进程共享的内存之外就是自己的独占内存了。所以要计算进程独占内存的大小只要用RES的值减去SHR值即可。 这片文章主要简单讲解Linux下进程的内存映射布局。 内存管理是操作系统的核心; 这对于编程和系统管理都至关重要。 进程的内存划分方案本节主要讨论进程内存映射的内部组织细节，我们假定的程序地址空间的范围在0到$2^N$，其中N是32或者64。 不同的多任务或者多用户操作系统拥有不同的内存映射布局。对于Linux进程的虚拟内存映射来说，其遵循图4所示的映射方案。 无论平台的进程内存划分方案多么特殊，下面几个内存映射的节(section)都是必须支持的: 代码节：该段包含了供CPU执行的机器码指令(.text节)。 数据节：该段包含了供CPU操作的数据。通常来说，初始化数据(.data节)、为初始化数据(.bss节)和只读数据(.rdata节)会保存在分离的节中。 堆：动态内存分配的区域。 栈：为各个函数提供了独立的存储空间。 最上层部分属于内核区域，特定进程的环境变量就存放在该区域。 二进制文件、编译器、连接器与装载器的作用粗略地讲： 程序的二进制文件中包含了程序运行过程中的内存映射布局的细节。 链接器创建了二进制文件的整体框架。要实现这项功能，链接器要对编译器生成的二进制文件进行合并，然后想各个内存映射节填充信息(代码和数据等信息)。 进程内存映射的初始化建立工作是由程序装载器这一系统工具完成的。在最简单的情况下，装载器会打开二进制可执行文件，读取节的相关信息，然后将这些信息载入进程内存映射结构中。 所有现代操作系统都是按照这种角色分离的方式设计的。 需要注意的是，以上描述是一个粗略地描述。 文章参考:12[1]: 探索 Linux 内存模型： https://www.ibm.com/developerworks/cn/linux/l-memmod/[2]: 理解VIRT/RES/SHR之间的关系: http://orchome.com/298]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>memory</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CPP使用Smart Pointer]]></title>
    <url>%2F2018%2F01%2F01%2Fcpp_smart_ptr%2F</url>
    <content type="text"><![CDATA[他山之石 可以攻玉 – 《诗经·小雅·鹤鸣》 Smart Pointer 引入原因使用 Raw Pointer 管理动态内存时，经常会遇到这样的问题： 忘记delete内存，造成内存泄露 出现异常时，不会执行delete，造成内存泄露 下面的代码解释了，当一个操作发生异常时，会导致delete不会被执行：1234567void func() &#123; auto ptr = new Widget; // 执行一个会抛出异常的操作 func_throw_exception(); delete ptr;&#125; 在 C++98 中我们需要用一种笨拙的方式，写出异常安全的代码：1234567891011void func() &#123; auto ptr = new Widget; try &#123; func_throw_exception(); &#125; catch(...) &#123; delete ptr; throw; &#125; delete ptr;&#125; C++11 使用 Smart Pointer 能轻易写出异常安全的代码，因为当对象退出作用域时, Smart Pointer 将自动调用对象的析构函数，避免内存泄露：1234void func() &#123; std::unique_ptr&lt;Widget&gt; ptr&#123; new Widget &#125;; func_throw_exception();&#125; Smart Pointer 使用方法Smart Pointer 在 头文件的 std 名称空间中定义。 它们对于RAII或资源获取初始化编程惯用语至关重要。 这个习惯用法的主要目标是确保资源获取在对象被初始化的同时进行，以便在一行代码中创建和准备对象的所有资源。 实际上，RAII的主要原则是将任何堆分配的资源（例如，动态分配的内存或系统对象句柄）归属给一个堆栈分配的对象，该对象的析构函数包含删除或释放资源的代码， 还有任何相关的清理代码。 在大多数情况下，初始化 Raw Pointer 或资源句柄以指向实际资源时，请立即将指针传递给Smart Pointer。在现代C++中，Raw Pointer 仅用于有限范围，循环或辅助函数的小代码块，其中性能至关重要，并且不存在对所有权混淆的可能性。 以下示例将 Raw Pointer 声明与 Smart Pointer 声明进行比较。123456789101112131415161718192021// 使用 Raw Pointervoid UseRawPointer() &#123; // 使用 Raw Pointer -- 不推荐 Song* pSong = new Song(L"Nothing on You", L"Bruno Mars"); // Use pSong... // 使用完成后，不要忘记释放申请的空间 delete pSong; &#125;// 使用 Smart Pointervoid UseSmartPointer() &#123; // 在堆栈上声明一个 Smart Pointer 并将其传递给 Raw Pointer -- 推荐 unique_ptr&lt;Song&gt; song2(new Song(L"Nothing on You", L"Bruno Mars")); // Use song2... wstring s = song2-&gt;duration_; //...&#125; // song2 该程序块执行完后自动删除 如示例中所示， Smart Pointer 是您在堆栈中声明的类模板，并使用指向堆分配对象的 Raw Pointer 进行初始化。 Smart Pointer 初始化后，它拥有 Raw Pointer 。这意味着 Smart Pointer 负责删除 Raw Pointer 指定的内存。 Smart Pointer 析构函数包含对删除的调用，并且因为 Smart Pointer 在堆栈中声明，所以当 Smart Pointer 超出作用域时，即使在堆栈之后的某处抛出异常，也会调用析构函数。 通过使用熟悉的指针操作符 -&gt; 和 * 来访问封装的指针， Smart Pointer 类重载该指针来返回封装的 Raw Pointer 。 C++ Smart Pointer 的对象创建：您创建对象，然后让系统在正确的时间删除它。不同之处在于没有单独的垃圾收集器在后台运行; 内存通过标准C++范围规则进行管理，以便运行时环境更快，更高效。 总是在单独的代码行上创建Smart Pointer，而不是在参数列表中创建，以便由于某些参数列表分配规则而不会发生细微的资源泄漏。 以下示例显示了如何使用标准模板库中的unique_ptrSmart Pointer类型来封装指向大对象的指针。1234567891011121314151617class LargeObject &#123;public: void DoSomething()&#123;&#125;&#125;;void ProcessLargeObject(const LargeObject&amp; lo)&#123;&#125;void SmartPointerDemo() &#123; // Create the object and pass it to a smart pointer std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject()); //Call a method on the object pLarge-&gt;DoSomething(); // Pass a reference to a method. ProcessLargeObject(*pLarge);&#125; //pLarge is deleted automatically when function block goes out of scope. 该示例演示了使用 Smart Pointer 的以下基本步骤: 将Smart Pointer声明为自动（本地）变量– 不要在Smart Pointer本身上使用new 或 malloc 表达式 在类型参数中，指定封装指针的指向类型 将一个Raw Pointer传递给Smart Pointer构造函数中的新对象– Some utility functions or smart pointer constructors do this for you 使用重载的 -&gt; 和 * 运算符来访问该对象 让 Smart Pointer 删除对象 Smart Pointer 的设计在内存和性能方面尽可能高效。 例如，unique_ptr中唯一的数据成员是封装的指针。 这意味着 unique_ptr 与该指针的大小完全相同，可以是四个字节，也可以是八个字节。 通过使用Smart Pointer重载的 * 和 -&gt; 操作符访问封装的指针不会比直接访问 Raw Pointer 慢得多。 Smart Pointer有自己的成员函数，可以用“.”符号来访问。 例如，一些STL Smart Pointer有一个 reset member function ，释放指针的所有权。 如果您想在 Smart Pointer 超出范围之前释放 Smart Pointer 所拥有的内存，这非常有用，如下例所示。12345678910111213void SmartPointerDemo2() &#123; // Create the object and pass it to a smart pointer std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject()); //Call a method on the object pLarge-&gt;DoSomething(); // Free the memory before we exit function block. pLarge.reset(); // Do some other work...&#125; Smart Pointer 类型 unique_ptr 仅允许一个底层指针的所有者 可以移动到新的所有者，但不能复制或共享 unique_ptr小而高效, 大小是一个指针 它支持右值引用，以便从STL集合中快速插入和检索 头文件：&lt;memory&gt; shared_ptr 引用计数的Smart Pointer 当您想要将一个Raw Pointer分配给多个所有者时使用，例如，当您从容器中返回指针的副本但想保留Raw Pointer时。 直到所有shared_ptr所有者超出范围或放弃所有权之后，才会删除Raw Pointer 大小是两个指针, 一个用于对象，另一个用于包含引用计数的共享控制块 头文件：&lt;memory&gt; weak_ptr 与shared_ptr结合使用的特例Smart Pointer weak_ptr 提供对一个或多个shared_ptr实例拥有的对象的访问权限，但不参与引用计数 当你想观察一个物体时使用，但不要求它保持活着。在某些情况下需要中断shared_ptr实例之间的循环引用。 头文件：&lt;memory&gt; 创建和使用unique_ptr实例A unique_ptr不会共享它的指针。 无法将它复制到另一个unique_ptr，（除非它是可修改rvalue） 通过值传递给函数，或需要对其进行复制的任何标准模板库 (STL) 算法中使用。 A unique_ptr只能移动。 这意味着内存资源的所有权将转移到新的unique_ptr和原始unique_ptr不再拥有它。 我们建议您将一个对象限制为一个所有者，因为拥有多个程序逻辑增加复杂性。 因此，当您需要为普通的 C++ 对象的 Smart Pointer ，使用unique_ptr。 下图说明了两个转让所有权unique_ptr实例。 移动 unique_ptr 的所有权, unique_ptr在中定义 STL 中的标头。 它是完全有效与 Raw Pointer ，可以使用 STL 容器中。 添加unique_ptr是有效的实例的 STL 容器因为移动构造函数的unique_ptr不需要复制操作。 示例 下面的示例演示如何创建unique_ptr实例，并在函数之间传递它们。12345678910111213141516171819202122232425262728293031323334// // Created by Eter J on 2017/12/31.//#include &lt;iostream&gt;#include &lt;memory&gt;struct Foo &#123; Foo() &#123; std::cout &lt;&lt; "Foo::Foo\n"; &#125; ~Foo() &#123; std::cout &lt;&lt; "Foo::~Foo\n"; &#125; void bar() &#123; std::cout &lt;&lt; "Foo::bar\n"; &#125;&#125;;void f(const Foo &amp;foo)&#123; std::cout &lt;&lt; "f(const Foo&amp;)\n";&#125;int main()&#123; std::unique_ptr&lt;Foo&gt; p1(new Foo); // p1 owns Foo if (p1) p1-&gt;bar(); &#123; std::unique_ptr&lt;Foo&gt; p2(std::move(p1)); // now p2 owns Foo f(*p2); p1 = std::move(p2); // ownership returns to p1 std::cout &lt;&lt; "destroying p2...\n"; &#125; if (p1) p1-&gt;bar(); // Foo instance is destroyed when p1 goes out of scope&#125; 12345678910111213141516171819unique_ptr&lt;Song&gt; SongFactory(std::wstring artist, std::wstring title) &#123; // Implicit move operation into the variable that stores the result. return unique_ptr&lt;Song&gt;(new Song(artist, title));&#125;void MakeSongs() &#123; // Create a new unique_ptr with a new object. unique_ptr&lt;Song&gt; pSong = unique_ptr&lt;Song&gt;(new Song(L"Mr. Children", L"Namonaki Uta")); // Use the unique_ptr vector&lt;wstring&gt; titles; titles.push_back(pSong-&gt;title); // Move raw pointer from one unique_ptr to another. unique_ptr&lt;Song&gt; pSong2 = std::move(pSong); // Obtain unique_ptr from function that returns rvalue reference. auto pSong3 = SongFactory(L"Michael Jackson", L"Beat It");&#125; 这些例子演示了unique_ptr的基本特征：它可以被移动，但不能被复制。 “移动”将所有权转移到新的unique_ptr并重置旧的unique_ptr。 以下示例显示如何创建unique_ptr实例并在矢量中使用它们12345678910111213141516void SongVector() &#123; vector&lt;unique_ptr&lt;Song&gt;&gt; v; // Create a few new unique_ptr&lt;Song&gt; instances // and add them to vector using implicit move semantics. v.push_back(unique_ptr&lt;Song&gt;(new Song(L"B'z", L"Juice"))); v.push_back(unique_ptr&lt;Song&gt;(new Song(L"Namie Amuro", L"Funky Town"))); v.push_back(unique_ptr&lt;Song&gt;(new Song(L"Kome Kome Club", L"Kimi ga Iru Dake de"))); v.push_back(unique_ptr&lt;Song&gt;(new Song(L"Ayumi Hamasaki", L"Poker Face"))); // Pass by reference to lambda body. for_each(v.begin(), v.end(), [] (const unique_ptr&lt;Song&gt;&amp; p) &#123; wcout &lt;&lt; L"Artist: " &lt;&lt; p-&gt;artist &lt;&lt; L"Title: " &lt;&lt; p-&gt;title &lt;&lt; endl; &#125;); &#125; 在for_each循环中，请注意unique_ptr是在lambda表达式中通过引用传递的。 如果你尝试在这里传值，编译器会抛出一个错误，因为unique_ptr拷贝构造函数被禁用。 以下示例显示如何初始化一个类成员unique_ptr。123456789101112131415161718class MyClass&#123;private: // MyClass owns the unique_ptr. unique_ptr&lt;ClassFactory&gt; factory;public: // Initialize by invoking the unique_ptr move constructor. MyClass() : factory ( unique_ptr&lt;ClassFactory&gt;(new ClassFactory())) &#123; &#125; void MakeClass() &#123; factory-&gt;DoSomething(); &#125;&#125;; 仅允许一个底层指针的所有者 可以移动到新的所有者，但不能复制或共享 创建和使用shared_ptr实例shared_ptr 类型是 Smart Pointer 在为方案设计多个所有者可能必须管理对象生存期内存中的 C++ 标准库中。 在初始化可以将它复制的 shared_ptr 后，将它在函数参数的值，并将其分配给其他 shared_ptr 实例。 所有实例指向同一对象，并且，对“的共享访问控制块”该引用计数的增量和减量，每当新 shared_ptr 添加，超出范围或重新设置。 当引用计数达到零时，控制块删除内存资源和自身。 下图显示了指向个内存位置的几 shared_ptr 实例。 1234567891011121314151617181920212223//// Created by Eter J on 2017/12/31.//#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class C &#123;&#125;;int main() &#123; shared_ptr&lt;C&gt; gp; &#123; C* ptr = new C; shared_ptr&lt;C&gt; sp(ptr); gp = sp ; cout &lt;&lt; "sp.use_count(): " &lt;&lt; sp.use_count() &lt;&lt; endl; cout &lt;&lt; "gp.use_count(): " &lt;&lt; gp.use_count() &lt;&lt; endl; &#125; cout &lt;&lt; "gp.use_count(): " &lt;&lt; gp.use_count() &lt;&lt; endl; return 0;&#125; OUTPUT: sp.use_count(): 1gp.use_count(): 2gp.use_count(): 1 创建和使用weak_ptr实例有时一个对象必须存储一个访问shared_ptr的底层对象的方法，而不会导致引用计数增加。通常情况下，如果在shared_ptr实例之间有循环引用，则会发生这种情况。 最好的设计是尽可能避免指针的共享所有权。但是，如果您必须共享shared_ptr实例的所有权，请避免它们之间的循环引用。当循环引用是不可避免的，或者由于某种原因更可取的时候，使用weak_ptr来给一个或多个所有者一个弱引用给另一个shared_ptr。通过使用weak_ptr，您可以创建一个shared_ptr，它将连接到现有的一组相关实例，但前提是基础内存资源仍然有效。 weak_ptr本身不参与引用计数，因此它不能阻止引用计数变为零。但是，可以使用weak_ptr尝试获取初始化的shared_ptr的新副本。如果内存已被删除，则抛出bad_weak_ptr异常。如果内存仍然有效，那么只要shared_ptr变量保持在作用域内，新的共享指针就会增加引用计数并保证内存有效。 下面的代码示例演示了weak_ptr用于确保正确删除具有循环依赖关系的对象的情况。当你检查这个例子时，假设它只是在考虑了其他解决方案之后才创建的。 Controller对象表示机器进程的某些方面，它们独立运行。每个控制器必须能够随时查询其他控制器的状态，并且每个控制器都包含一个专用矢量&lt;weak_ptr &lt;Controller&gt;&gt;。每个向量包含一个循环引用，因此，使用weak_ptr实例而不是shared_ptr。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//// Created by Eter J on 2018/1/1.//#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class Controller&#123;public: int Num; wstring Status; vector&lt;weak_ptr&lt;Controller&gt;&gt; others; explicit Controller(int i) : Num(i) , Status(L"On") &#123; wcout &lt;&lt; L"Creating Controller" &lt;&lt; Num &lt;&lt; endl; &#125; ~Controller() &#123; wcout &lt;&lt; L"Destroying Controller" &lt;&lt; Num &lt;&lt; endl; &#125; // Demonstrates how to test whether the // pointed-to memory still exists or not. void CheckStatuses() const &#123; for_each(others.begin(), others.end(), [] (weak_ptr&lt;Controller&gt; wp) &#123; try &#123; auto p = wp.lock(); wcout &lt;&lt; L"Status of " &lt;&lt; p-&gt;Num &lt;&lt; " = " &lt;&lt; p-&gt;Status &lt;&lt; endl; &#125; catch (bad_weak_ptr b) &#123; wcout &lt;&lt; L"Null object" &lt;&lt; endl; &#125; &#125;); &#125;&#125;;void RunTest()&#123; vector&lt;shared_ptr&lt;Controller&gt;&gt; v; v.push_back(shared_ptr&lt;Controller&gt;(new Controller(0))); v.push_back(shared_ptr&lt;Controller&gt;(new Controller(1))); v.push_back(shared_ptr&lt;Controller&gt;(new Controller(2))); v.push_back(shared_ptr&lt;Controller&gt;(new Controller(3))); v.push_back(shared_ptr&lt;Controller&gt;(new Controller(4))); // Each controller depends on all others not being deleted. // Give each controller a pointer to all the others. for (int i = 0 ; i &lt; v.size(); ++i) &#123; for_each(v.begin(), v.end(), [v,i] (shared_ptr&lt;Controller&gt; p) &#123; if(p-&gt;Num != i) &#123; v[i]-&gt;others.push_back(weak_ptr&lt;Controller&gt;(p)); wcout &lt;&lt; L"push_back to v[" &lt;&lt; i &lt;&lt; "]: " &lt;&lt; p-&gt;Num &lt;&lt; endl; &#125; &#125;); &#125; for_each(v.begin(), v.end(), [](shared_ptr&lt;Controller&gt;&amp; p) &#123; wcout &lt;&lt; L"use_count = " &lt;&lt; p.use_count() &lt;&lt; endl; p-&gt;CheckStatuses(); &#125;);&#125;int main()&#123; RunTest(); wcout &lt;&lt; L"Press any key" &lt;&lt; endl; char ch; cin.getline(&amp;ch, 1);&#125; OUTPUT Creating Controller0Creating Controller1Creating Controller2Creating Controller3Creating Controller4push_back to v[0]: 1push_back to v[0]: 2push_back to v[0]: 3push_back to v[0]: 4push_back to v[1]: 0push_back to v[1]: 2push_back to v[1]: 3push_back to v[1]: 4push_back to v[2]: 0push_back to v[2]: 1push_back to v[2]: 3push_back to v[2]: 4push_back to v[3]: 0push_back to v[3]: 1push_back to v[3]: 2push_back to v[3]: 4push_back to v[4]: 0push_back to v[4]: 1push_back to v[4]: 2push_back to v[4]: 3use_count = 1Status of 1 = OnStatus of 2 = OnStatus of 3 = OnStatus of 4 = Onuse_count = 1Status of 0 = OnStatus of 2 = OnStatus of 3 = OnStatus of 4 = Onuse_count = 1Status of 0 = OnStatus of 1 = OnStatus of 3 = OnStatus of 4 = Onuse_count = 1Status of 0 = OnStatus of 1 = OnStatus of 2 = OnStatus of 4 = Onuse_count = 1Status of 0 = OnStatus of 1 = OnStatus of 2 = OnStatus of 3 = OnDestroying Controller4Destroying Controller3Destroying Controller2Destroying Controller1Destroying Controller0Press any key]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>CPP</tag>
        <tag>Smart Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年更新计划]]></title>
    <url>%2F2018%2F01%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[坚持不懈 始终如一 每周至少更新两篇文章 每个月进行一次总结]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
